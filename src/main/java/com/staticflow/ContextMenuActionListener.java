package main.java.com.staticflow;

import burp.api.montoya.http.message.responses.HttpResponse;
import burp.api.montoya.ui.contextmenu.ContextMenuEvent;
import javax.swing.*;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.util.StringJoiner;

/**
 * This class implements a custom ActionListener which fires when a user click this extension's custom context menu.
 * When the user right-clicks the general workflow takes place:<br>
 * 1. The request+response, and issue name if the click context was a Scanner issue, are combined, base64 encoded, and post-pended to {@value REPORT_SUBMISSION_URL} 
 * 2. The resulting string from Step 1 is then opened within a new tab in the users default browser
 * 3. If Step 2 fails due to an overly long URL, Step 1 and 2 are tried again with only the Request, and issue name if in a Scanner issue context
 * 4. If Step 3 fails, the original URL from Step 1 is added to the users clipboard for opening manually
 */
public class ContextMenuActionListener implements ActionListener {

    //The last event to be captured by this extension's custom ContextMenuListener
    private ContextMenuEvent lastContextMenuEvent;
    //The constant URL at HackerOne where vulnerability meta-data can be sent to create a draft report
    private static final String REPORT_SUBMISSION_URL = "https://hackerone.com/submit-a-security-vulnerability#";

    /*
        Fired when the user clicks on this extension's custom context menu
     */
    @Override
    public void actionPerformed(ActionEvent e) {
        switch (lastContextMenuEvent.invocationType()) {
            //If the click happened within the context of a Repeater tab
            case MESSAGE_EDITOR_REQUEST -> {
                //attempt to base64 encode the Request+Response or just Request if too long
                String findingMetaDataURL = base64EncodeRepeaterData();
                ExtensionState.getInstance().getCallbacks().logging().logToOutput(findingMetaDataURL);
                //attempt to open the draft report URL in the users default browser
                try {
                    openURL(findingMetaDataURL);
                } catch (IOException ex) {
                    //if this fails, save URL to clipboard
                    sendToUserClipboard(findingMetaDataURL);
                }
            }
            //If the click happened within the context of a Scanner Issue
            case SCANNER_RESULTS -> {
                //If the Scanner Issue the user selected does not have a Request, ignore it.
                if( lastContextMenuEvent.selectedIssues().get(0).requestResponses().size() == 0) {
                    JOptionPane.showMessageDialog(
                            null,
                            "This issue does not have a Request to include in the finding MetaData."
                    );
                } else {
                    //attempt to base64 encode the Issue Name+Request+Response or just Issue Name+Request if too long
                    String findingMetaDataURL = base64EncodeScannerIssue();
                    ExtensionState.getInstance().getCallbacks().logging().logToOutput(findingMetaDataURL);
                    //attempt to open the draft report URL in the users default browser
                    try {
                        openURL(findingMetaDataURL);
                    } catch (IOException ex) {
                        //if this fails, save URL to clipboard
                        sendToUserClipboard(findingMetaDataURL);
                    }
                }
            }
            //This should never happen
            default -> ExtensionState.getInstance().getCallbacks().logging().logToOutput("Not covered " + lastContextMenuEvent.toolType().toolName());
        }
    }

    /**
     * Saves the generated finding MetaData URL to the user's clipboard
     * @param findingMetaDataURL the generated finding MetaData URL
     */
    private void sendToUserClipboard(String findingMetaDataURL) {
        StringSelection stringSelection = new StringSelection(findingMetaDataURL);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(stringSelection, null);
        JOptionPane.showMessageDialog(
                null,
                "The generated URL is too long to programmatically open. It has been added to your clipboard."
        );
    }

    /***
     * This method attempts to open the generated finding MetaData URL in the user's default web browser. Windows and OSX are covered natively, as well as Linux
     * through the use of a list of common browsers normally found on Lin(ux/ix) systems.
     * @param findingMetaDataURL The generated finding MetaData URL to attempt to open
     * @throws IOException If launching the user's default browser with the supplied URL fails (typically if the URL is too long)
     */
    private static void openURL(String findingMetaDataURL) throws IOException {
        //Get the user's OS name
        String os = System.getProperty("os.name").toLowerCase();
        //get a handle to the user's OS runtime
        Runtime rt = Runtime.getRuntime();

        if (os.contains("win")) {
            //if Windows, use the url.dll to open the supplied url
            rt.exec( "rundll32 url.dll,FileProtocolHandler " + findingMetaDataURL);
        } else if (os.contains("mac")) {
            //if OSX, use the "open" binary to open the supplied url
            rt.exec( "open " + findingMetaDataURL);

        } else if (os.endsWith("nix") || os.endsWith("nux")) {
            //If Linux, Build a list of browsers to try, in this order.
            String[] browsers = {"firefox", "mozilla", "chrome","opera"};

            // Build a command string which looks like "browser1 "url" || browser2 "url" ||..."
            StringBuilder cmd = new StringBuilder();
            for (int i=0; i<browsers.length; i++)
                cmd.append(i == 0 ? "" : " || ").append(browsers[i]).append(" \"").append(findingMetaDataURL).append("\" ");

            rt.exec(new String[] { "sh", "-c", cmd.toString() });

        }
    }

    /**
     * This method handles compressing the finding MetaData for a Repeater tab context and generating a URL with it.
     * @return A URL at {@value REPORT_SUBMISSION_URL} post-pended with the finding MetaData of the current context.
     */
    private String base64EncodeRepeaterData() {
        StringJoiner stringJoiner = new StringJoiner("\n");
        stringJoiner.add("Request:");
        stringJoiner.add("```");
        stringJoiner.add(lastContextMenuEvent.selectedRequestResponses().get(0).request().toString());
        stringJoiner.add("```");
        HttpResponse httpResponse = lastContextMenuEvent.selectedRequestResponses().get(0).response();
        addResponse(httpResponse, stringJoiner);
        return REPORT_SUBMISSION_URL+ExtensionState.getInstance().getCallbacks().utilities().base64Utils().encodeToString(stringJoiner.toString());
    }

    /**
     * This method handles compressing the finding MetaData for a Scanner Issue context and generating a URL with it.<br>
     * Currently, this context only uses the first Request+Response combo of a finding.
     * @return A URL at {@value REPORT_SUBMISSION_URL} post-pended with the finding MetaData of the current context.
     */
    private String base64EncodeScannerIssue() {
        StringJoiner stringJoiner = new StringJoiner("\n");
        stringJoiner.add("Issue Name:");
        stringJoiner.add("`" + lastContextMenuEvent.selectedIssues().get(0).name() + "`");
        stringJoiner.add("Request:");
        stringJoiner.add("```");
        stringJoiner.add(lastContextMenuEvent.selectedIssues().get(0).requestResponses().get(0).request().toString());
        stringJoiner.add("```");
        HttpResponse httpResponse = lastContextMenuEvent.selectedIssues().get(0).requestResponses().get(0).response();
        addResponse(httpResponse, stringJoiner);
        return REPORT_SUBMISSION_URL+ExtensionState.getInstance().getCallbacks().utilities().base64Utils().encodeToString(stringJoiner.toString());
    }

    /**
     * Called by {@link #base64EncodeRepeaterData()} and {@link #base64EncodeScannerIssue()} to include the Response MetaData if there is room for it.
     * @param httpResponse {@link HttpResponse} object containing the bytes of the Repeater or Scanner PoC web response
     * @param stringJoiner reference to the {@link StringJoiner} to append the HttpResponse to
     */
    private void addResponse(HttpResponse httpResponse, StringJoiner stringJoiner) {
        if (httpResponse != null) {
            String responseString = httpResponse.toString();
            if( stringJoiner.length()+responseString.length() < 32764) {
                stringJoiner.add("Response:");
                stringJoiner.add(responseString);
            }
        }
    }

    /**
     * Called by {@link CustomContextMenuProvider#provideMenuItems(ContextMenuEvent)} to set the current {@link ContextMenuEvent} this ActionListener should act on
     * @param lastContextMenuEvent The current {@link ContextMenuEvent} this ActionListener should act on
     */
    public void setLastContextMenuEvent(ContextMenuEvent lastContextMenuEvent) {
        this.lastContextMenuEvent = lastContextMenuEvent;
    }
}
